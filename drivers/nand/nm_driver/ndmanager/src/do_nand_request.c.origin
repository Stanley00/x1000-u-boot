//#include <stdio.h>
//#include <stdlib.h>
//#include <linux/string.h>
#include <malloc.h>
#include "convert_img.h"
#include "jz4775.h"

#define SECTOR_SIZE 512
#define MAX_PARTITION_NUM 20
struct Ghandle{
	int zmhanle;
	int eraseallflag;
};
#define ZM_MEMORY_SIZE  (8*1024*1024)
int  pphandle[MAX_PARTITION_NUM] = {-1};
int pphandle_index = 0;
LPartition* lp;
int handle;
int blocknum = 0;
int sectorid = 0;
int curpt_index = 0;
PPartition *m_ppt;
static int uperrorpt = 1;
extern int pagesize;
extern int ppb;
extern int nd_raw_boundary;
int nd_rbcnt = 1;
/*for one rb*/
Nandppt ndppt[7]={{"ndxboot",0,8,0,0},{"ndboot",8,16,1,0},{"ndrecovery",24,16,1,0},{"ndsystem",64,512,2,0},{"nddata",(576+128),1024,2,0},{"ndcache",576,128,2,0},{"ndmisc",(576+128+1024),/*794624*/-1,2,0}};

/*for two rb --> 16G*/
//Nandppt ndppt[7]={{"ndxboot",0,1024*2,0,0},{"ndboot",1024*2,2048*2,1,0},{"ndrecovery",3072*2,2048*2,1,0},{"ndsystem",8192*2,65536,2,0},{"nddata",81920,131072,2,0},{"ndcache",212992,16384,2,0},{"ndmisc",229376,1884160,2,0}};
//Nandppt ndppt[7]={{"ndxboot",0,1024,0,0},{"ndboot",1024,2048,1,0},{"ndrecovery",3072,2048,1,0},{"ndsystem",8192,65536,2,0},{"nddata",73728,131072,2,0},{"ndcache",204800,16384,2,0},{"ndmisc",221184,/*1884160*/-1,2,0}};
extern int nand_probe(PartitionInfo *pinfo);

static int jz_strcmp(char *s1, char *s2)
{
  while (*s1 != '\0' && *s1 == *s2)
    {
      s1++;
      s2++;
    }

  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
}

static void start(int handle)
{
	struct Ghandle *ghandle = (struct Ghandle*)handle;

	m_ppt = ((PManager*)(ghandle->zmhanle))->vnand->pt->ppt;
	switch (ghandle->eraseallflag) {
	case 1:
		serial_printf("NANDMANAGER: Nand Manager normal erase all the flash!\n");
		NandManger_Ioctrl(ghandle->zmhanle, NANDMANAGER_NORMAL_ERASE_FLASH, 0);
		break;
	case 2:
		serial_printf("NANDMANAGER: Nand Manager force erase all the flash!\n");
		NandManger_Ioctrl(ghandle->zmhanle, NANDMANAGER_FORCE_ERASE_FLASH, 0);
                /*if force eraseall,then skip erase each partition before write*/
		uperrorpt = 0;
		break;
	case 3:
		serial_printf("NANDMANAGER: Nand Manager prepare new flash!\n");
		NandManger_Ioctrl(ghandle->zmhanle, NANDMANAGER_PREPARE_NEW_FLASH, 0);
		break;
	default:
		break;
	}

	serial_printf("NANDMANAGER: Nand Manager scan bad blocks!\n");
	NandManger_Ioctrl(ghandle->zmhanle, NANDMANAGER_SCAN_BADBLOCKS,0);
	/*update all the partition with CPU_OPS for read/write/erase*/
	NandManger_getPartition(ghandle->zmhanle,&lp);
}

unsigned int jz_strlen(const char *s)
{
    int len = 0;
    while(*s++) len++;
    return len;
}

char * jz_strncpy(char *dest,const char *src, unsigned int count)
{
	char *tmp = dest;

	while(count){
		if((*dest = *src) != 0)
			src++;
		dest++;
		count--;
	}
	return dest;
}

int burn_nandmanager_init(PartitionInfo *pinfo, int eraseall)
{
	void *heap;
	struct Ghandle m_ghandle;
	struct Ghandle *ghandle = &m_ghandle;
	
	heap = (void*)malloc(ZM_MEMORY_SIZE);
	if(!heap){
		printf("%s %d error!\n",__func__,__LINE__);
		return -1;
	}
	//printf("%s %d\n",__FILE__,__LINE__);
	//check_code();
	handle = NandManger_Init(heap,ZM_MEMORY_SIZE,0);
	ghandle->zmhanle = handle;
	ghandle->eraseallflag = eraseall;
	NandManger_startNotify(handle,start,(int)(ghandle));
	nd_rbcnt = pinfo->rbcount;
	nand_probe(pinfo);
	return handle;
}

unsigned int do_nand_request(unsigned int startaddr, void *Bulk_out_buf, unsigned int ops_length)
{
	int pHandle;
	void *databuf = Bulk_out_buf;
	char *readbuf;
	int totalbytes = ops_length * pagesize;
	unsigned int wlen = 0;
	SectorList *sl;
	int rsectorid;
	int bl;
	int bytes = 0,pt_index;
	int ret = startaddr + ops_length;
	int pt_startpage,pt_endpage;

	readbuf = malloc(512*1024); //GFP_KERNEL = 0;
	if(!readbuf)
	{
		ndd_printf("ERROR: alloc readbuf error !!\n");
		return -1;
	}
	/*handle two rb,find the correct pt_index*/
	if(nd_rbcnt > 1 && startaddr != 0){
		if(startaddr*pagesize < 64*1024*1024)
			startaddr *= 2;
		else
			startaddr += (nd_raw_boundary * ppb);
	}
	for(pt_index = 0; pt_index < MAX_PARTITION_NUM; pt_index++){
		pt_startpage = m_ppt[pt_index].startPage;
		pt_endpage = pt_startpage + m_ppt[pt_index].totalblocks * m_ppt[pt_index].pageperblock;
		//serial_printf("$$$$ pt_index=%d startpage=%d endpage=%d startaddr=%d  nd_raw_boundary=%d$$$$$\n",pt_index,pt_startpage,pt_endpage,startaddr,nd_raw_boundary);
		if( pt_startpage <= startaddr && (startaddr + ops_length) < pt_endpage){
			break;
		}
	}
	if(pt_index == MAX_PARTITION_NUM)
		serial_printf("%s ERROR !!!!!!!!!!!!!!!!!!\n",__func__);
	serial_printf("pt[%d]:%s ops_length = %d pagesize=%d totalbytes=%d\n",pt_index,__func__,ops_length,pagesize,totalbytes);
	pHandle = pphandle[pt_index];
	if(curpt_index != pt_index){
		sectorid = 0;
		curpt_index = pt_index;
	}

	if(pHandle == -1){
		serial_printf("the partition is not open,so the handle is -1,checkout the index!\n");
		return -1;
	}
	bl = BuffListManager_BuffList_Init();
	if(bl == 0){
		serial_printf("BuffListManager Init failed!\n");
		return -1;
	}

	while(totalbytes){
		if(totalbytes >= 256 *512)
			wlen = 256 * 512;
		else{
			wlen = totalbytes;
			if(wlen % 512 != 0)
				memset(databuf+wlen, 0xff, 512-wlen%512);
		}
		sl = BuffListManager_getTopNode(bl,sizeof(SectorList));
		if(sl == 0){
			serial_printf("Bufferlist request sectorlist failed!\n");
			return -1;
		}
		rsectorid = sectorid;
		sl->startSector = sectorid;
		sl->pData = (void*)databuf;
		sl->sectorCount = (wlen + 511)/ 512;
		sectorid += (wlen + 511)/ 512;
		serial_printf("%s write:sectorid:%d sectorCount:%d curpt_index=%d pt_index=%d pHandle=%x sl[%x]\n",
			      __func__,sl->startSector,sl->sectorCount,curpt_index,pt_index,pHandle,(int)sl);
rewrite:
		if(NandManger_ptWrite(pHandle,sl) < 0){
			serial_printf("NandManger_ptWrite failed, now rewrite!\n");
			goto rewrite;
		}
		if(sl->startSector == 0){
			sl->sectorCount = (wlen + 511)/ 512;
		}
		sl->startSector = rsectorid;
		sl->pData = (void*)readbuf;
		if(NandManger_ptRead(pHandle,sl) < 0){
			serial_printf("NandManger_ptRead failed, now rewrite!\n");
			goto rewrite;
		}
		databuf+=wlen;
		totalbytes-=wlen;
		BuffListManager_freeAllList(bl,(void **)&sl,sizeof(SectorList));
	}
	BuffListManager_BuffList_DeInit(bl);

	return ret;
}

static int NM_PtDirecterase(PPartition *pt)
{
	int blockid,markcnt;
	int ret;
	BlockList bl;

	serial_printf("%s info: pt[%s] totalblocks= %d\n",__func__,pt->name,pt->totalblocks);
	for(blockid = 0; blockid < pt->totalblocks; blockid++){
		bl.startBlock = blockid;
		bl.BlockCount = 1;
		bl.head.next = NULL;
/*		if(NandManger_DirectIsBadBlock(0, pt, &bl)){
			serial_printf("xxxxxxxxxxx WARNING xxxxxxxxxx\n");
			serial_printf("%s pt[%s]:blockid=%d is badblock!\n",__func__,pt->name,blockid);
			serial_printf("xxxxxxxxxxx ENDING xxxxxxxxxx\n");
			continue;
		}
*/
		ret = NandManger_DirectErase(0, pt, &bl);
		if(ret){
			ret = NandManger_DirectMarkBadBlock(0, pt, blockid);
			if(ret){
				serial_printf("============== ERROR ATENTION ================\n");
				serial_printf("%s DirectMarkBadBlock Fail. pt[%s],blockid=%d,ret=%d\n",__func__,pt->name,blockid,ret);
				serial_printf("=============== MARK FAILED ==================\n");
			}
			markcnt++;
		}
	}
	return markcnt;
}

int NM_erase_and_updataerrpt(int blocknum, int startblockid)
{
	LPartition *lpentry;
	struct singlelist *it;
	int pt_index,ret = 0;
	PPartition *pt;
	if(nd_rbcnt > 1 && startblockid != 0){
		if(startblockid*ppb*pagesize < 64*1024*1024)
			startblockid *= 2;
		else
			startblockid += nd_raw_boundary;
	}

	//serial_printf("[%s]-------> startblockid=%d nd_raw_boundary=%d\n",__func__,startblockid,nd_raw_boundary);
	for(pt_index = 0; pt_index < MAX_PARTITION_NUM; pt_index++){
		if(m_ppt[pt_index].startblockID == startblockid){
			if(m_ppt[pt_index].totalblocks != blocknum)
				serial_printf("pt[%s] erase totalblocks [%d] change to [%d]\n",
					      m_ppt[pt_index].name,blocknum,m_ppt[pt_index].totalblocks);
			break;
		}

	}
	if(pt_index == MAX_PARTITION_NUM){
		serial_printf("\nERROR !\n"
			      "---------------------------------ATTENTION--------------------------------\n"
			      "the file startpage[%d] isn't match the partitioninfo you had filled in UI.\n"
			      "please check the file startpage in UI and then refill\n!",startblockid*ppb);
		while(1);
	}
	pt = &m_ppt[pt_index];
        /*splmanager and simplemanager will erase and update its partition*/
	if(pt_index < 2)
		goto exit;
	if(uperrorpt){
		NM_PtDirecterase(pt);
		ret = vNand_UpdateErrorPartition(((PManager*)handle)->vnand, pt);
	}
exit:
	singlelist_for_each(it,&lp->head){
		lpentry = singlelist_entry(it,LPartition,head);
		if(jz_strcmp(lpentry->name,pt->name) == 0){
			pphandle[pphandle_index] = NandManger_ptOpen(handle,lpentry->name,lpentry->mode);
			//serial_printf("pt[%s] erase ok,update errorpt ok,and ptopen ok! pphandle_index=%d handle=%x\n",pt->name,pphandle_index,pphandle[pphandle_index]);
			pphandle_index = 0;
			break;
		}
		pphandle_index++;
	}

	return ret;
}
